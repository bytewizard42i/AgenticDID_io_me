/**
 * AgenticDID Registry Contract
 * 
 * Manages agent identity registration and verification
 * Stores DID -> public key mappings with privacy
 * Handles credential issuance and revocation
 * 
 * Built for: Google Cloud Run Hackathon + Midnight Network
 * Privacy: Zero-knowledge proofs for agent verification
 * 
 * Compact Version: 0.26
 * Compiler: compactc_v0.26.0_x86_64-unknown-linux-musl
 */

pragma language_version 0.26;
import CompactStandardLibrary;
  
// ============================================================================
// STATE VARIABLES (Ledger-based persistent storage)
// ============================================================================

ledger agentCredentials: Map<Bytes<32>, AgentCredential>;
ledger delegations: Map<Bytes<32>, Delegation>;
ledger totalAgents: Uint<64>;
ledger totalDelegations: Uint<64>;
ledger contractOwner: Address;
ledger revocationBitmap: Uint<256>;  // Bitmap for revoked agents (max 256 agents)
  
  // ============================================================================
  // DATA STRUCTURES
  // ============================================================================
  
struct AgentCredential {
  did: Bytes<32>;           // Agent DID hash
  publicKey: Bytes<64>;     // Public key for verification
  role: Bytes<32>;          // Role hash (e.g., hash("banker"))
  scopes: Bytes<32>;        // Scope hash (bitfield of permissions)
  issuedAt: Uint<64>;       // Timestamp of credential issuance
  expiresAt: Uint<64>;      // Expiration timestamp
  issuer: Address;          // Who issued this credential
  isActive: Bool;           // Quick active/revoked check
}
  
struct Delegation {
  delegationId: Bytes<32>;  // Unique delegation ID
  userDID: Bytes<32>;       // User's DID
  agentDID: Bytes<32>;      // Delegated agent's DID
  scopes: Bytes<32>;        // Delegated scopes (subset of agent's)
  createdAt: Uint<64>;      // When delegation was created
  expiresAt: Uint<64>;      // When delegation expires
  isRevoked: Bool;          // Revocation status
}
  
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  
/**
 * Initialize the registry contract
 * Sets up the contract owner and initial state
 */
export circuit initialize(owner: Address): [] {
  totalAgents = 0;
  totalDelegations = 0;
  contractOwner = owner;
  revocationBitmap = 0;
}
  
  // ============================================================================
  // AGENT REGISTRATION
  // ============================================================================
  
  /**
   * Register a new agent with credentials
   * 
   * @param caller - Address of the caller
   * @param did - Agent's DID (hash)
   * @param publicKey - Agent's public key
   * @param role - Agent's role hash
   * @param scopes - Agent's permission scopes
   * @param expiresAt - Credential expiration timestamp
   * @param currentTime - Current block timestamp
   * @param zkProof - Zero-knowledge proof of agent ownership
   */
export circuit registerAgent(
  caller: Address,
  did: Bytes<32>,
  publicKey: Bytes<64>,
  role: Bytes<32>,
  scopes: Bytes<32>,
  expiresAt: Uint<64>,
  currentTime: Uint<64>,
  zkProof: Bytes<>
): [] {
  
  // Security checks (using assert instead of require)
  assert(!agentCredentials.has(did), "Agent already registered");
  assert(expiresAt > currentTime, "Invalid expiration time");
  assert(verifyProofOfOwnership(did, publicKey, zkProof), "Invalid proof");
  
  // Create credential (using let instead of const)
  let credential = AgentCredential {
    did: did,
    publicKey: publicKey,
    role: role,
    scopes: scopes,
    issuedAt: currentTime,
    expiresAt: expiresAt,
    issuer: caller,
    isActive: true
  };
  
  // Store in ledger
  agentCredentials.set(did, credential);
  
  // Update counter
  totalAgents = totalAgents + 1;
}
  
  // ============================================================================
  // AGENT VERIFICATION
  // ============================================================================
  
  /**
   * Verify an agent's credential with zero-knowledge proof
   * Returns true if valid and not revoked
   * 
   * @param agentDID - Agent's DID to verify
   * @param proofHash - Hash of the verification proof
   * @param currentTime - Current timestamp
   */
export circuit verifyAgent(
  agentDID: Bytes<32>,
  proofHash: Bytes<32>,
  currentTime: Uint<64>
): Bool {
    
    // Check if agent exists (safe map access)
    if (!agentCredentials.has(agentDID)) {
      return false;
    }
    
    let credential = agentCredentials.get(agentDID);
    
    // Check expiration
    if (credential.expiresAt < currentTime) {
      return false;
    }
    
    // Check revocation status
    if (!credential.isActive) {
      return false;
    }
    
    // Verify proof matches
    let expectedHash = hashProof(credential.publicKey, currentTime);
    if (proofHash != expectedHash) {
      return false;
    }
    
    return true;
  }
  
/**
 * Get agent's public key (for verification)
 * This is public information needed for ZKP verification
 */
export circuit getAgentPublicKey(agentDID: Bytes<32>): Bytes<64> {
  assert(agentCredentials.has(agentDID), "Agent not found");
  return agentCredentials.get(agentDID).publicKey;
}
  
  // ============================================================================
  // DELEGATION MANAGEMENT
  // ============================================================================
  
  /**
   * Create a delegation from user to agent
   * Allows agent to act on behalf of user with limited scopes
   * 
   * @param caller - User's address
   * @param userDID - User's DID
   * @param agentDID - Agent's DID to delegate to
   * @param scopes - Scopes to delegate
   * @param expiresAt - When delegation expires
   * @param currentTime - Current timestamp
   */
export circuit createDelegation(
  caller: Address,
  userDID: Bytes<32>,
  agentDID: Bytes<32>,
  scopes: Bytes<32>,
  expiresAt: Uint<64>,
  currentTime: Uint<64>
): Bytes<32> {
  
  // Verify agent exists and is active
  assert(agentCredentials.has(agentDID), "Agent not found");
  let agentCred = agentCredentials.get(agentDID);
  assert(agentCred.isActive, "Agent is revoked");
  
  // Verify scopes are subset of agent's scopes
  assert(scopesAreSubset(scopes, agentCred.scopes), "Invalid scopes");
  
  // Create unique delegation ID
  let delegationId = hashDelegation(userDID, agentDID, currentTime);
  
  // Create delegation
  let delegation = Delegation {
    delegationId: delegationId,
    userDID: userDID,
    agentDID: agentDID,
    scopes: scopes,
    createdAt: currentTime,
    expiresAt: expiresAt,
    isRevoked: false
  };
  
  // Store delegation
  delegations.set(delegationId, delegation);
  
  // Update counter
  totalDelegations = totalDelegations + 1;
  
  return delegationId;
}
  
  /**
   * Check if a delegation is valid
   */
export circuit isDelegationValid(
  delegationId: Bytes<32>,
  currentTime: Uint<64>
): Bool {
    
    if (!delegations.has(delegationId)) {
      return false;
    }
    
    let delegation = delegations.get(delegationId);
    
    // Check revocation
    if (delegation.isRevoked) {
      return false;
    }
    
    // Check expiration
    if (delegation.expiresAt < currentTime) {
      return false;
    }
    
    // Check if agent is still active
    if (!agentCredentials.has(delegation.agentDID)) {
      return false;
    }
    
    let agentCred = agentCredentials.get(delegation.agentDID);
    if (!agentCred.isActive) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Revoke a delegation
   * Only the user who created it can revoke
   */
export circuit revokeDelegation(
  caller: Address,
  delegationId: Bytes<32>
): [] {
  
  assert(delegations.has(delegationId), "Delegation not found");
  
  let delegation = delegations.get(delegationId);
  assert(!delegation.isRevoked, "Already revoked");
  
  // Update delegation
  let updatedDelegation = Delegation {
    delegationId: delegation.delegationId,
    userDID: delegation.userDID,
    agentDID: delegation.agentDID,
    scopes: delegation.scopes,
    createdAt: delegation.createdAt,
    expiresAt: delegation.expiresAt,
    isRevoked: true
  };
  
  delegations.set(delegationId, updatedDelegation);
}
  
  // ============================================================================
  // AGENT REVOCATION
  // ============================================================================
  
  /**
   * Revoke an agent's credential
   * Only contract owner or issuer can revoke
   */
export circuit revokeAgent(
  caller: Address,
  agentDID: Bytes<32>
): [] {
  
  assert(agentCredentials.has(agentDID), "Agent not found");
  
  let credential = agentCredentials.get(agentDID);
  
  // Only owner or issuer can revoke
  assert(
    caller == contractOwner || caller == credential.issuer,
    "Not authorized"
  );
  
  // Update credential
  let updatedCred = AgentCredential {
    did: credential.did,
    publicKey: credential.publicKey,
    role: credential.role,
    scopes: credential.scopes,
    issuedAt: credential.issuedAt,
    expiresAt: credential.expiresAt,
    issuer: credential.issuer,
    isActive: false  // Mark as revoked
  };
  
  agentCredentials.set(agentDID, updatedCred);
}
  
  // ============================================================================
  // HELPER FUNCTIONS (Private)
  // ============================================================================
  
  /**
   * Verify proof of ownership (ZKP verification)
   * In production, this would use actual ZKP verification
   */
circuit verifyProofOfOwnership(
  did: Bytes<32>,
  publicKey: Bytes<64>,
  proof: Bytes<>
): Bool {
  // Simplified for demo
  // In production: Verify ZK-SNARK proof
  return proof.length() > 0;
}
  
  /**
   * Hash a proof for verification
   */
circuit hashProof(
  publicKey: Bytes<64>,
  timestamp: Uint<64>
): Bytes<32> {
  // Simplified hash function
  // In production: Use proper cryptographic hash
  return 0x0000000000000000000000000000000000000000000000000000000000000000;  // Placeholder
}
  
  /**
   * Hash delegation parameters to create unique ID
   */
circuit hashDelegation(
  userDID: Bytes<32>,
  agentDID: Bytes<32>,
  timestamp: Uint<64>
): Bytes<32> {
  // Simplified hash
  return 0x0000000000000000000000000000000000000000000000000000000000000000;  // Placeholder
}
  
  /**
   * Check if requested scopes are subset of available scopes
   */
circuit scopesAreSubset(
  requested: Bytes<32>,
  available: Bytes<32>
): Bool {
  // Simplified bitwise AND check
  // In production: Proper scope verification
  return true;  // Placeholder
}
  
// ============================================================================
// EXPORTED CIRCUITS FOR CROSS-CONTRACT CALLS
// ============================================================================

/**
 * Check if agent credential is valid
 * Called by CredentialVerifier for verification
 * Uses assert() pattern for idiomatic error handling
 */
export circuit checkCredential(
  agentDID: Bytes<32>,
  currentTime: Uint<64>
): [] {
  // Check if agent exists
  assert(agentCredentials.has(agentDID), "Agent not found");
  
  let credential = agentCredentials.get(agentDID);
  
  // Validation chain using assert
  assert(credential.isActive, "Agent not active");
  assert(credential.expiresAt >= currentTime, "Credential expired");
  
  // Check revocation bitmap
  let agentIndex = getAgentIndex(agentDID);
  assert(!isRevoked(agentIndex), "Agent revoked");
  
  // If we reach here, credential is valid!
}

/**
 * Check if delegation is valid
 * Called by CredentialVerifier for delegation verification
 */
export circuit isDelegationValid(
  userDID: Bytes<32>,
  agentDID: Bytes<32>,
  requiredScopes: Bytes<32>,
  currentTime: Uint<64>
): [] {
  // Generate delegation ID
  let delegationId = hashDelegation(userDID, agentDID, currentTime);
  
  // Check if delegation exists
  assert(delegations.has(delegationId), "Delegation not found");
  
  let delegation = delegations.get(delegationId);
  
  // Validation chain
  assert(delegation.isActive, "Delegation not active");
  assert(delegation.expiresAt >= currentTime, "Delegation expired");
  assert(scopesAreSubset(requiredScopes, delegation.scopes), "Scope mismatch");
  
  // If we reach here, delegation is valid!
}

// ============================================================================
// HELPER FUNCTIONS (Private)
// ============================================================================

  /**
   * Helper to create bytes32 from uint8
   */
