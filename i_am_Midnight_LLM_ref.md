# Midnight LLM Reference - Complete API Documentation

**@midnight-ntwrk/compact-runtime v0.9.0**  
**Complete TypeScript API Reference**  
**Updated**: October 28, 2025

> ðŸ¤– **Comprehensive API reference for LLM training and development assistance**

---

## Table of Contents

1. [API Overview](#api-overview)
2. [Enumerations](#enumerations)
3. [Classes](#classes)
4. [Interfaces](#interfaces)
5. [Type Aliases](#type-aliases)
6. [Variables](#variables)
7. [Functions](#functions)

---

## API Overview

The `@midnight-ntwrk/compact-runtime` library provides runtime primitives used by Compact's TypeScript output. It re-exports items from `@midnight-ntwrk/onchain-runtime` and wraps others in a TypeScript-friendly API.

**Key Components**:
- Network configuration
- Circuit execution context
- State management
- Cryptographic primitives
- Zswap (shielded tokens)
- Type conversions

---

## Enumerations

### NetworkId

The network currently being targeted.

```typescript
enum NetworkId {
  Undeployed = 0,  // Local test network
  DevNet = 1,       // Developer network (not persistent)
  TestNet = 2,      // Persistent testnet
  MainNet = 3       // Midnight mainnet
}
```

---

## Classes

### CompactError

An error originating from code generated by the Compact compiler.

```typescript
class CompactError extends Error {
  constructor(msg: string): CompactError;
  message: string;
  name: string;
  stack?: string;
}
```

---

### CompactTypeBoolean

Runtime type of the builtin `Boolean` type.

```typescript
class CompactTypeBoolean implements CompactType<boolean> {
  alignment(): Alignment;
  fromValue(value: Value): boolean;
  toValue(value: boolean): Value;
}
```

---

### CompactTypeBytes

Runtime type of the builtin `Bytes` types.

```typescript
class CompactTypeBytes implements CompactType<Uint8Array> {
  constructor(length: number);
  readonly length: number;
  
  alignment(): Alignment;
  fromValue(value: Value): Uint8Array;
  toValue(value: Uint8Array): Value;
}
```

---

### CompactTypeCurvePoint

Runtime type of `CurvePoint`.

```typescript
class CompactTypeCurvePoint implements CompactType<CurvePoint> {
  alignment(): Alignment;
  fromValue(value: Value): CurvePoint;
  toValue(value: CurvePoint): Value;
}
```

---

### CompactTypeEnum

Runtime type of an enum with a given number of entries.

```typescript
class CompactTypeEnum implements CompactType<number> {
  constructor(maxValue: number, length: number);
  readonly maxValue: number;
  readonly length: number;
  
  alignment(): Alignment;
  fromValue(value: Value): number;
  toValue(value: number): Value;
}
```

---

### CompactTypeField

Runtime type of the builtin `Field` type.

```typescript
class CompactTypeField implements CompactType<bigint> {
  alignment(): Alignment;
  fromValue(value: Value): bigint;
  toValue(value: bigint): Value;
}
```

---

### CompactTypeMerkleTreeDigest

Runtime type of `MerkleTreeDigest`.

```typescript
class CompactTypeMerkleTreeDigest implements CompactType<MerkleTreeDigest> {
  alignment(): Alignment;
  fromValue(value: Value): MerkleTreeDigest;
  toValue(value: MerkleTreeDigest): Value;
}
```

---

### CompactTypeMerkleTreePath<a>

Runtime type of `MerkleTreePath`.

```typescript
class CompactTypeMerkleTreePath<a> implements CompactType<MerkleTreePath<a>> {
  constructor(n: number, leaf: CompactType<a>);
  readonly leaf: CompactType<a>;
  readonly path: CompactTypeVector<MerkleTreePathEntry>;
  
  alignment(): Alignment;
  fromValue(value: Value): MerkleTreePath<a>;
  toValue(value: MerkleTreePath<a>): Value;
}
```

---

### CompactTypeMerkleTreePathEntry

Runtime type of `MerkleTreePathEntry`.

```typescript
class CompactTypeMerkleTreePathEntry implements CompactType<MerkleTreePathEntry> {
  readonly bool: CompactTypeBoolean;
  readonly digest: CompactTypeMerkleTreeDigest;
  
  alignment(): Alignment;
  fromValue(value: Value): MerkleTreePathEntry;
  toValue(value: MerkleTreePathEntry): Value;
}
```

---

### CompactTypeOpaqueString

Runtime type of `Opaque["string"]`.

```typescript
class CompactTypeOpaqueString implements CompactType<string> {
  alignment(): Alignment;
  fromValue(value: Value): string;
  toValue(value: string): Value;
}
```

---

### CompactTypeOpaqueUint8Array

Runtime type of `Opaque["Uint8Array"]`.

```typescript
class CompactTypeOpaqueUint8Array implements CompactType<Uint8Array> {
  alignment(): Alignment;
  fromValue(value: Value): Uint8Array;
  toValue(value: Uint8Array): Value;
}
```

---

### CompactTypeVector<a>

Runtime type of the builtin `Vector` types.

```typescript
class CompactTypeVector<a> implements CompactType<a[]> {
  constructor(length: number, type: CompactType<a>);
  readonly length: number;
  readonly type: CompactType<a>;
  
  alignment(): Alignment;
  fromValue(value: Value): a[];
  toValue(value: a[]): Value;
}
```

---

### ContractMaintenanceAuthority

A committee permitted to make changes to this contract.

```typescript
class ContractMaintenanceAuthority {
  constructor(
    committee: string[], 
    threshold: number, 
    counter?: bigint
  );
  
  readonly committee: string[];       // Committee public keys
  readonly threshold: number;          // Required signatures
  readonly counter: bigint;            // Replay protection counter
  
  serialize(networkid: NetworkId): Uint8Array;
  toString(compact?: boolean): string;
  static deserialize(raw: Uint8Array, networkid: NetworkId): ContractState;
}
```

---

### ContractOperation

An individual operation/entry point of a contract.

```typescript
class ContractOperation {
  verifierKey: Uint8Array;
  
  serialize(networkid: NetworkId): Uint8Array;
  toString(compact?: boolean): string;
  static deserialize(raw: Uint8Array, networkid: NetworkId): ContractOperation;
}
```

---

### ContractState

The state of a contract.

```typescript
class ContractState {
  constructor();  // Creates blank contract state
  
  data: StateValue;                              // Primary state
  maintenanceAuthority: ContractMaintenanceAuthority;
  
  operation(operation: string | Uint8Array): undefined | ContractOperation;
  operations(): (string | Uint8Array)[];
  query(query: Op<null>[], cost_model: CostModel): GatherResult[];
  serialize(networkid: NetworkId): Uint8Array;
  setOperation(operation: string | Uint8Array, value: ContractOperation): void;
  toString(compact?: boolean): string;
  static deserialize(raw: Uint8Array, networkid: NetworkId): ContractState;
}
```

---

### CostModel

A cost model for calculating transaction fees.

```typescript
class CostModel {
  toString(compact?: boolean): string;
  static dummyCostModel(): CostModel;
}
```

---

### QueryContext

Provides information needed to process a transaction.

```typescript
class QueryContext {
  constructor(state: StateValue, address: string);
  
  readonly address: string;
  block: BlockContext;
  readonly comIndicies: Map<string, bigint>;
  effects: Effects;
  readonly state: StateValue;
  
  insertCommitment(comm: string, index: bigint): QueryContext;
  intoTranscript(program: Op<AlignedValue>[], cost_model: CostModel): 
    [undefined | Transcript<AlignedValue>, undefined | Transcript<AlignedValue>];
  qualify(coin: Value): undefined | Value;
  query(ops: Op<null>[], cost_model: CostModel, gas_limit?: bigint): QueryResults;
  runTranscript(transcript: Transcript<AlignedValue>, cost_model: CostModel): QueryContext;
  toString(compact?: boolean): string;
}
```

---

### QueryResults

The results of making a query against a specific state.

```typescript
class QueryResults {
  readonly context: QueryContext;
  readonly events: GatherResult[];
  readonly gasCost: bigint;
  
  toString(compact?: boolean): string;
}
```

---

### StateBoundedMerkleTree

Fixed-depth Merkle tree storing hashed data.

```typescript
class StateBoundedMerkleTree {
  constructor(height: number);
  readonly height: number;
  
  collapse(start: bigint, end: bigint): StateBoundedMerkleTree;
  findPathForLeaf(leaf: AlignedValue): AlignedValue;
  pathForLeaf(index: bigint, leaf: AlignedValue): AlignedValue;
  root(): Value;
  toString(compact?: boolean): string;
  update(index: bigint, leaf: AlignedValue): StateBoundedMerkleTree;
}
```

---

### StateMap

Key-value map with AlignedValue keys and StateValue values.

```typescript
class StateMap {
  constructor();
  
  get(key: AlignedValue): undefined | StateValue;
  insert(key: AlignedValue, value: StateValue): StateMap;
  keys(): AlignedValue[];
  remove(key: AlignedValue): StateMap;
  toString(compact?: boolean): string;
}
```

---

### StateValue

Contract state representation (immutable).

```typescript
class StateValue {
  arrayPush(value: StateValue): StateValue;
  asArray(): undefined | StateValue[];
  asBoundedMerkleTree(): undefined | StateBoundedMerkleTree;
  asCell(): AlignedValue;
  asMap(): undefined | StateMap;
  encode(): EncodedStateValue;
  logSize(): number;
  toString(compact?: boolean): string;
  type(): "map" | "null" | "cell" | "array" | "boundedMerkleTree";
  
  static decode(value: EncodedStateValue): StateValue;
  static newArray(): StateValue;
  static newBoundedMerkleTree(tree: StateBoundedMerkleTree): StateValue;
  static newCell(value: AlignedValue): StateValue;
  static newMap(map: StateMap): StateValue;
  static newNull(): StateValue;
}
```

---

### VmResults

Results of a VM call.

```typescript
class VmResults {
  readonly events: GatherResult[];
  readonly gasCost: bigint;
  readonly stack: VmStack;
  
  toString(compact?: boolean): string;
}
```

---

### VmStack

VM stack state at a specific point.

```typescript
class VmStack {
  constructor();
  
  get(idx: number): undefined | StateValue;
  isStrong(idx: number): undefined | boolean;
  length(): number;
  push(value: StateValue, is_strong: boolean): void;
  removeLast(): void;
  toString(compact?: boolean): string;
}
```

---

## Interfaces

### CircuitContext<T>

External information accessible from within a Compact circuit call.

```typescript
interface CircuitContext<T> {
  currentPrivateState: T;
  currentZswapLocalState: EncodedZswapLocalState;
  originalState: ContractState;
  transactionContext: QueryContext;
}
```

---

### CircuitResults<T, U>

Results of a Compact circuit call.

```typescript
interface CircuitResults<T, U> {
  context: CircuitContext<T>;
  proofData: ProofData;
  result: U;
}
```

---

### CompactType<a>

Runtime representation of a type in Compact.

```typescript
interface CompactType<a> {
  alignment(): Alignment;
  fromValue(value: Value): a;
  toValue(value: a): Value;
}
```

---

### ConstructorContext<T>

Passed to contract constructor.

```typescript
interface ConstructorContext<T> {
  initialPrivateState: T;
  initialZswapLocalState: EncodedZswapLocalState;
}
```

---

### ConstructorResult<T>

Result of executing a contract constructor.

```typescript
interface ConstructorResult<T> {
  currentContractState: ContractState;
  currentPrivateState: T;
  currentZswapLocalState: EncodedZswapLocalState;
}
```

---

### CurvePoint

A point in the embedded elliptic curve.

```typescript
interface CurvePoint {
  readonly x: bigint;
  readonly y: bigint;
}
```

---

### EncodedCoinInfo

A CoinInfo with its fields encoded as byte strings. This representation is used internally by the contract executable.

```typescript
interface EncodedCoinInfo {
  readonly nonce: Uint8Array;      // Coin's randomness, prevents collisions
  readonly color: Uint8Array;      // Coin's type, identifies currency
  readonly value: bigint;          // Coin's value in atomic units (64-bit)
}
```

**Properties**:
- `nonce`: The coin's randomness, preventing it from colliding with other coins
- `color`: The coin's type, identifying the currency it represents
- `value`: The coin's value, in atomic units dependent on the currency. Bounded to be a non-negative 64-bit integer

---

### EncodedCoinPublicKey

A CoinPublicKey encoded as a byte string. This representation is used internally by the contract executable.

```typescript
interface EncodedCoinPublicKey {
  readonly bytes: Uint8Array;      // The coin public key's bytes
}
```

---

### EncodedContractAddress

A ContractAddress encoded as a byte string. This representation is used internally by the contract executable.

```typescript
interface EncodedContractAddress {
  readonly bytes: Uint8Array;      // The contract address's bytes
}
```

---

### EncodedQualifiedCoinInfo

A QualifiedCoinInfo with its fields encoded as byte strings. This representation is used internally by the contract executable.

```typescript
interface EncodedQualifiedCoinInfo {
  readonly nonce: Uint8Array;      // Coin's randomness, prevents collisions
  readonly color: Uint8Array;      // Coin's type, identifies currency
  readonly value: bigint;          // Coin's value in atomic units (64-bit)
  readonly mt_index: bigint;       // Coin's Merkle tree location (64-bit)
}
```

**Properties**:
- `nonce`: The coin's randomness, preventing it from colliding with other coins
- `color`: The coin's type, identifying the currency it represents
- `value`: The coin's value, in atomic units dependent on the currency. Bounded to be a non-negative 64-bit integer
- `mt_index`: The coin's location in the chain's Merkle tree of coin commitments. Bounded to be a non-negative 64-bit integer

---

### EncodedRecipient

A Recipient with its fields encoded as byte strings. This representation is used internally by the contract executable.

```typescript
interface EncodedRecipient {
  readonly is_left: boolean;                    // User or contract?
  readonly left: EncodedCoinPublicKey;          // Recipient's public key (if user)
  readonly right: EncodedContractAddress;       // Recipient's address (if contract)
}
```

**Properties**:
- `is_left`: Whether the recipient is a user or a contract
- `left`: The recipient's public key, if the recipient is a user
- `right`: The recipient's contract address, if the recipient is a contract

---

### EncodedZswapLocalState

Tracks the coins consumed and produced throughout circuit execution.

```typescript
interface EncodedZswapLocalState {
  coinPublicKey: EncodedCoinPublicKey;          // User's Zswap public key
  currentIndex: bigint;                         // Next coin's Merkle tree index
  inputs: EncodedQualifiedCoinInfo[];           // Coins consumed as inputs
  outputs: {                                     // Coins produced as outputs
    coinInfo: EncodedCoinInfo;
    recipient: EncodedRecipient;
  }[];
}
```

**Properties**:
- `coinPublicKey`: The Zswap coin public key of the user executing the circuit
- `currentIndex`: The Merkle tree index of the next coin produced
- `inputs`: The coins consumed as inputs to the circuit
- `outputs`: The coins produced as outputs from the circuit

---

### MerkleTreeDigest

The hash value of a Merkle tree. TypeScript representation of the Compact type of the same name.

```typescript
interface MerkleTreeDigest {
  readonly field: bigint;
}
```

---

### MerkleTreePath<a>

A path demonstrating inclusion in a Merkle tree. TypeScript representation of the Compact type of the same name.

```typescript
interface MerkleTreePath<a> {
  readonly leaf: a;
  readonly path: MerkleTreePathEntry[];
}
```

---

### MerkleTreePathEntry

An entry in a Merkle path. TypeScript representation of the Compact type of the same name.

```typescript
interface MerkleTreePathEntry {
  readonly sibling: MerkleTreeDigest;
  readonly goes_left: boolean;
}
```

---

### ProofData

Encapsulates the data required to produce a zero-knowledge proof.

```typescript
interface ProofData {
  input: AlignedValue;                          // Circuit inputs
  output: AlignedValue;                         // Circuit outputs
  privateTranscriptOutputs: AlignedValue[];     // Witness call outputs
  publicTranscript: Op<AlignedValue>[];         // Public operations transcript
}
```

**Properties**:
- `input`: The inputs to a circuit
- `output`: The outputs from a circuit
- `privateTranscriptOutputs`: The transcript of the witness call outputs
- `publicTranscript`: The public transcript of operations

---

### Recipient

The recipient of a coin produced by a circuit.

```typescript
interface Recipient {
  readonly is_left: boolean;      // User or contract?
  readonly left: string;          // Recipient's public key (if user)
  readonly right: string;         // Recipient's address (if contract)
}
```

**Properties**:
- `is_left`: Whether the recipient is a user or a contract
- `left`: The recipient's public key, if the recipient is a user
- `right`: The recipient's contract address, if the recipient is a contract

---

### WitnessContext<L, T>

The external information accessible from within a Compact witness call.

```typescript
interface WitnessContext<L, T> {
  readonly ledger: L;                 // Projected ledger state
  readonly privateState: T;            // Current private state
  readonly contractAddress: string;    // Contract being called
}
```

**Properties**:
- `ledger`: The projected ledger state, if the transaction were to run against the ledger state as you locally see it currently
- `privateState`: The current private state for the contract
- `contractAddress`: The address of the contract being called

---

### ZswapLocalState

Tracks the coins consumed and produced throughout circuit execution.

```typescript
interface ZswapLocalState {
  coinPublicKey: string;                // User's Zswap public key
  currentIndex: bigint;                  // Next coin's Merkle tree index
  inputs: QualifiedCoinInfo[];          // Coins consumed as inputs
  outputs: {                             // Coins produced as outputs
    coinInfo: CoinInfo;
    recipient: Recipient;
  }[];
}
```

**Properties**:
- `coinPublicKey`: The Zswap coin public key of the user executing the circuit
- `currentIndex`: The Merkle tree index of the next coin produced
- `inputs`: The coins consumed as inputs to the circuit
- `outputs`: The coins produced as outputs from the circuit

---

## Type Aliases

### AlignedValue

An onchain data value, in field-aligned binary format, annotated with its alignment.

```typescript
type AlignedValue = {
  alignment: Alignment;
  value: Value;
};
```

---

### Alignment

The alignment of an onchain field-aligned binary data value.

```typescript
type Alignment = AlignmentSegment[];
```

---

### AlignmentAtom

An atom in a larger Alignment.

```typescript
type AlignmentAtom = 
  | { tag: "compress"; }
  | { tag: "field"; }
  | { tag: "bytes"; length: number; };
```

---

### AlignmentSegment

A segment in a larger Alignment.

```typescript
type AlignmentSegment = 
  | { tag: "option"; value: Alignment[]; }
  | { tag: "atom"; value: AlignmentAtom; };
```

---

### BlockContext

The context information about a block available inside the VM.

```typescript
type BlockContext = {
  blockHash: string;                  // Hex-encoded block hash
  secondsSinceEpoch: bigint;          // Seconds since UNIX epoch
  secondsSinceEpochErr: number;       // Maximum error (positive seconds)
};
```

**Properties**:
- `blockHash`: The hash of the block prior to this transaction, as a hex-encoded string
- `secondsSinceEpoch`: The seconds since the UNIX epoch that have elapsed
- `secondsSinceEpochErr`: The maximum error on secondsSinceEpoch that should occur, as a positive seconds value

---

### CoinCommitment

A Zswap coin commitment, as a hex-encoded 256-bit bitstring.

```typescript
type CoinCommitment = string;
```

---

### CoinInfo

Information required to create a new coin, alongside details about the recipient.

```typescript
type CoinInfo = {
  nonce: Nonce;           // Coin's randomness (prevents collisions)
  type: TokenType;        // Coin's type (identifies currency)
  value: bigint;          // Coin's value in atomic units (64-bit)
};
```

**Properties**:
- `nonce`: The coin's randomness, preventing it from colliding with other coins
- `type`: The coin's type, identifying the currency it represents
- `value`: The coin's value, in atomic units dependent on the currency. Bounded to be a non-negative 64-bit integer

---

### CoinPublicKey

A user public key capable of receiving Zswap coins, as a hex-encoded 35-byte string.

```typescript
type CoinPublicKey = string;
```

---

### ContractAddress

A contract address, as a hex-encoded 35-byte string.

```typescript
type ContractAddress = string;
```

---

### ContractReferenceLocations

A data structure indicating the locations of all contract references in a given ledger state.

```typescript
type ContractReferenceLocations = EmptyPublicLedger | PublicLedgerSegments;
```

If it is a `EmptyPublicLedger`, then no contract references are present in the ledger state. If it is a `PublicLedgerSegments`, then contract references are present and can be extracted using `contractDependencies`.

---

### DomainSeperator

A token domain separator, the pre-stage of TokenType, as 32-byte bytearray.

```typescript
type DomainSeperator = Uint8Array;
```

---

### Effects

The contract-external effects of a transcript.

```typescript
type Effects = {
  claimedNullifiers: Nullifier[];                          // Spends required
  claimedReceives: CoinCommitment[];                       // Outputs as receives
  claimedSpends: CoinCommitment[];                         // Outputs as sends
  claimedContractCalls: [bigint, ContractAddress, string, Fr][];  // Calls made
  mints: Map<string, bigint>;                              // Tokens minted
};
```

**Properties**:
- `claimedNullifiers`: The nullifiers (spends) this contract call requires
- `claimedReceives`: The coin commitments (outputs) this contract call requires, as coins received
- `claimedSpends`: The coin commitments (outputs) this contract call requires, as coins sent
- `claimedContractCalls`: The contracts called from this contract. The values are, in order:
  - The sequence number of this call
  - The contract being called
  - The entry point being called
  - The communications commitment
- `mints`: The tokens minted in this call, as a map from hex-encoded 256-bit domain separators to non-negative 64-bit integers

---

### Fr

An internal encoding of a value of the proof system's scalar field.

```typescript
type Fr = Uint8Array;
```

---

### GatherResult

An individual result of observing the results of a non-verifying VM program execution.

```typescript
type GatherResult = 
  | { tag: "read"; content: AlignedValue; }
  | { tag: "log"; content: EncodedStateValue; };
```

---

### Key

A key used to index into an array or map in the onchain VM.

```typescript
type Key = 
  | { tag: "value"; value: AlignedValue; }
  | { tag: "stack"; };
```

---

### Nonce

A Zswap nonce, as a hex-encoded 256-bit string.

```typescript
type Nonce = string;
```

---

### Nullifier

A Zswap nullifier, as a hex-encoded 256-bit bitstring.

```typescript
type Nullifier = string;
```

---

### Op<R>

An individual operation in the onchain VM.

```typescript
type Op<R> = 
  | { noop: { n: number; }; }
  | "lt" | "eq" | "type" | "size" | "new"
  | "and" | "or" | "neg" | "log" | "root" | "pop"
  | { popeq: { cached: boolean; result: R; }; }
  | { addi: { immediate: number; }; }
  | { subi: { immediate: number; }; }
  | { push: { storage: boolean; value: EncodedStateValue; }; }
  | { branch: { skip: number; }; }
  | { jmp: { skip: number; }; }
  | "add" | "sub"
  | { concat: { cached: boolean; n: number; }; }
  | "member"
  | { rem: { cached: boolean; }; }
  | { dup: { n: number; }; }
  | { swap: { n: number; }; }
  | { idx: { cached: boolean; path: Key[]; pushPath: boolean; }; }
  | { ins: { cached: boolean; n: number; }; }
  | "ckpt";
```

**Type Parameters**:
- `R`: `null` or `AlignedValue`, for gathering and verifying mode respectively

---

### QualifiedCoinInfo

Information required to spend an existing coin, alongside authorization of the owner.

```typescript
type QualifiedCoinInfo = {
  mt_index: bigint;       // Merkle tree index (64-bit)
  nonce: Nonce;           // Coin's randomness (prevents collisions)
  type: TokenType;        // Coin's type (identifies currency)
  value: bigint;          // Coin's value in atomic units (64-bit)
};
```

**Properties**:
- `mt_index`: The coin's location in the chain's Merkle tree of coin commitments. Bounded to be a non-negative 64-bit integer
- `nonce`: The coin's randomness, preventing it from colliding with other coins
- `type`: The coin's type, identifying the currency it represents
- `value`: The coin's value, in atomic units dependent on the currency. Bounded to be a non-negative 64-bit integer

---

### Signature

A hex-encoded signature BIP-340 signature, with a 3-byte version prefix.

```typescript
type Signature = string;
```

---

### SignatureVerifyingKey

A hex-encoded signature BIP-340 verifying key, with a 3-byte version prefix.

```typescript
type SignatureVerifyingKey = string;
```

---

### SigningKey

A hex-encoded signature BIP-340 signing key, with a 3-byte version prefix.

```typescript
type SigningKey = string;
```

---

### SparseCompactADT

A discriminated union describing the locations of contract references in either a Compact Cell, List, Set, or Map ADT.

```typescript
type SparseCompactADT = 
  | SparseCompactCellADT
  | SparseCompactArrayLikeADT
  | SparseCompactMapADT;
```

---

### SparseCompactArrayLikeADT

A data structure indicating the locations of all contract references in a Compact Set or List ADT.

```typescript
type SparseCompactArrayLikeADT = 
  | SparseCompactSetADT
  | SparseCompactListADT;
```

---

### SparseCompactCellADT

A data structure indicating the locations of all contract references in a Compact Cell ADT.

```typescript
type SparseCompactCellADT = {
  tag: "cell";
  valueType: SparseCompactValue;
};
```

**Properties**:
- `tag`: Discriminator tag "cell"
- `valueType`: A data structure indicating the locations of all contract references in the Compact value contained in the outer Cell ADT

---

### TokenType

A token type identifier, as a hex-encoded 256-bit string.

```typescript
type TokenType = string;
```

---

## Functions

### Core Functions

#### setNetworkId
```typescript
function setNetworkId(networkId: NetworkId): void;
```
Required to ensure the right network is being targeted.

---

### Hashing Functions

#### transientHash
```typescript
function transientHash<a>(rt_type: CompactType<a>, value: a): bigint;
```
Circuit-efficient compression function (not persistent between upgrades).

#### transientCommit
```typescript
function transientCommit<a>(
  rt_type: CompactType<a>, 
  value: a, 
  opening: bigint
): bigint;
```
Circuit-efficient commitment function (not persistent).

#### persistentHash
```typescript
function persistentHash<a>(rt_type: CompactType<a>, value: a): Uint8Array;
```
Persistent hash function for mostly arbitrary data. Throws if type contains Opaque elements.

#### persistentCommit
```typescript
function persistentCommit<a>(
  rt_type: CompactType<a>, 
  value: a, 
  opening: Uint8Array
): Uint8Array;
```
Persistent commitment function. Throws if type contains Opaque elements or opening is not 32 bytes.

#### degradeToTransient
```typescript
function degradeToTransient(x: Uint8Array): bigint;
```
Degrades persistent hash/commit to field element. Throws if x is not 32 bytes.

#### upgradeFromTransient
```typescript
function upgradeFromTransient(x: bigint): Uint8Array;
```
Upgrades transient hash/commit to 256-bit byte string. Throws if x is not a valid field element.

---

### Elliptic Curve Functions

#### ecAdd
```typescript
function ecAdd(a: CurvePoint, b: CurvePoint): CurvePoint;
```
Add two elliptic curve points.

#### ecMul
```typescript
function ecMul(a: CurvePoint, b: bigint): CurvePoint;
```
Multiply elliptic curve point by scalar.

#### ecMulGenerator
```typescript
function ecMulGenerator(b: bigint): CurvePoint;
```
Multiply primary group generator by scalar.

#### hashToCurve
```typescript
function hashToCurve<a>(rt_type: CompactType<a>, x: a): CurvePoint;
```
Maps arbitrary values to elliptic curve points. Outputs have unknown discrete logarithm.

---

### Zswap Functions

#### createZswapInput
```typescript
function createZswapInput(
  circuitContext: CircuitContext<unknown>, 
  qualifiedCoinInfo: EncodedQualifiedCoinInfo
): void;
```
Adds coin to list of inputs consumed by circuit.

#### createZswapOutput
```typescript
function createZswapOutput(
  circuitContext: CircuitContext<unknown>, 
  coinInfo: EncodedCoinInfo, 
  recipient: EncodedRecipient
): void;
```
Adds coin to list of outputs produced by circuit.

#### ownPublicKey
```typescript
function ownPublicKey(circuitContext: CircuitContext<unknown>): EncodedCoinPublicKey;
```
Retrieves Zswap coin public key of user executing circuit.

#### tokenType
```typescript
function tokenType(domain_sep: DomainSeperator, contract: string): string;
```
Derives TokenType for a domain separator and contract.

---

### Encoding/Decoding Functions

#### encodeCoinInfo
```typescript
function encodeCoinInfo(coin: CoinInfo): EncodedCoinInfo;
```

#### decodeCoinInfo
```typescript
function decodeCoinInfo(coin: EncodedCoinInfo): CoinInfo;
```

#### encodeQualifiedCoinInfo
```typescript
function encodeQualifiedCoinInfo(coin: QualifiedCoinInfo): EncodedQualifiedCoinInfo;
```

#### decodeQualifiedCoinInfo
```typescript
function decodeQualifiedCoinInfo(coin: EncodedQualifiedCoinInfo): QualifiedCoinInfo;
```

#### encodeCoinPublicKey
```typescript
function encodeCoinPublicKey(pk: string): Uint8Array;
```

#### decodeCoinPublicKey
```typescript
function decodeCoinPublicKey(pk: Uint8Array): string;
```

#### encodeContractAddress
```typescript
function encodeContractAddress(addr: string): Uint8Array;
```

#### decodeContractAddress
```typescript
function decodeContractAddress(addr: Uint8Array): string;
```

#### encodeRecipient
```typescript
function encodeRecipient(recipient: Recipient): EncodedRecipient;
```

#### decodeRecipient
```typescript
function decodeRecipient(recipient: EncodedRecipient): Recipient;
```

#### encodeTokenType
```typescript
function encodeTokenType(tt: string): Uint8Array;
```

#### decodeTokenType
```typescript
function decodeTokenType(tt: Uint8Array): string;
```

#### encodeZswapLocalState
```typescript
function encodeZswapLocalState(state: ZswapLocalState): EncodedZswapLocalState;
```

#### decodeZswapLocalState
```typescript
function decodeZswapLocalState(state: EncodedZswapLocalState): ZswapLocalState;
```

---

### Context Functions

#### constructorContext
```typescript
function constructorContext<T>(
  initialPrivateState: T, 
  coinPublicKey: string
): ConstructorContext<T>;
```
Creates new ConstructorContext with empty Zswap local state.

#### witnessContext
```typescript
function witnessContext<L, T>(
  ledger: L, 
  privateState: T, 
  contractAddress: string
): WitnessContext<L, T>;
```
Internal constructor for WitnessContext.

#### emptyZswapLocalState
```typescript
function emptyZswapLocalState(coinPublicKey: string): EncodedZswapLocalState;
```
Constructs empty EncodedZswapLocalState.

---

### Utility Functions

#### runProgram
```typescript
function runProgram(
  initial: VmStack, 
  ops: Op<null>[], 
  cost_model: CostModel, 
  gas_limit?: bigint
): VmResults;
```
Runs VM program against initial stack.

#### checkProofData
```typescript
function checkProofData(zkir: string, proofData: ProofData): void;
```
Verifies ProofData satisfies ZK circuit constraints. Throws if not satisfied.

#### contractDependencies
```typescript
function contractDependencies(
  contractReferenceLocations: ContractReferenceLocations, 
  state: StateValue
): string[];
```
Extracts contract addresses present in ledger state.

---

### Testing Functions

#### sampleContractAddress
```typescript
function sampleContractAddress(): string;
```
Samples uniform contract address for testing.

#### sampleTokenType
```typescript
function sampleTokenType(): string;
```
Samples uniform token type for testing.

#### sampleSigningKey
```typescript
function sampleSigningKey(): string;
```
Randomly samples a SigningKey.

#### dummyContractAddress
```typescript
function dummyContractAddress(): string;
```
Sample contract address, same for given network ID.

---

### Signature Functions

#### signData
```typescript
function signData(key: string, data: Uint8Array): string;
```
Signs arbitrary data with signing key. WARNING: Do not expose for valuable keys!

#### signatureVerifyingKey
```typescript
function signatureVerifyingKey(sk: string): string;
```
Returns verifying key for given signing key.

#### verifySignature
```typescript
function verifySignature(vk: string, data: Uint8Array, signature: string): boolean;
```
Verifies if signature is correct.

---

### Internal/Compiler Functions

#### assert
```typescript
function assert(b: boolean, s: string): void;
```
Compiler internal for assertions.

#### type_error
```typescript
function type_error(who: string, what: string, where: string, type: string, x: any): never;
```
Compiler internal for type errors.

#### convert_bigint_to_Uint8Array
```typescript
function convert_bigint_to_Uint8Array(n: number, x: bigint): Uint8Array;
```
Compiler internal for typecasts.

#### convert_Uint8Array_to_bigint
```typescript
function convert_Uint8Array_to_bigint(n: number, a: Uint8Array): bigint;
```
Compiler internal for typecasts.

#### bigIntToValue
```typescript
function bigIntToValue(x: bigint): Value;
```
Internal conversion between bigints and field-aligned binary.

#### valueToBigInt
```typescript
function valueToBigInt(x: Value): bigint;
```
Internal conversion between field-aligned binary and bigints. Throws if value doesn't encode field element.

#### alignedConcat
```typescript
function alignedConcat(...values: AlignedValue[]): AlignedValue;
```
Concatenates multiple AlignedValues.

#### coinCommitment
```typescript
function coinCommitment(coin: AlignedValue, recipient: AlignedValue): AlignedValue;
```
Internal implementation of coin commitment primitive.

#### leafHash
```typescript
function leafHash(value: AlignedValue): AlignedValue;
```
Internal implementation of Merkle tree leaf hash primitive.

#### maxAlignedSize
```typescript
function maxAlignedSize(alignment: Alignment): bigint;
```
Internal implementation of max aligned size primitive.

---

## Variables

### BooleanDescriptor
Descriptor for Boolean type.

### Bytes32Descriptor
Descriptor for Bytes<32> type.

### CoinInfoDescriptor
Descriptor for CoinInfo type.

### CoinRecipientDescriptor
Descriptor for coin recipient type.

### ContractAddressDescriptor
Descriptor for ContractAddress type.

### DUMMY_ADDRESS
Sample dummy address constant.

### MAX_FIELD
Maximum field element value.

### MaxUint8Descriptor
Descriptor for maximum Uint8 value.

### versionString
Version string for the runtime.

### ZswapCoinPublicKeyDescriptor
Descriptor for ZswapCoinPublicKey type.

---

## Usage Patterns

### Creating a Circuit Context

```typescript
import { constructorContext, emptyZswapLocalState } from '@midnight-ntwrk/compact-runtime';

const initialState = { /* your private state */ };
const coinPublicKey = "user_public_key";
const zswapState = emptyZswapLocalState(coinPublicKey);
const context = constructorContext(initialState, coinPublicKey);
```

### Hashing for Privacy

```typescript
import { persistentHash, persistentCommit, CompactTypeField } from '@midnight-ntwrk/compact-runtime';

// Hash a value
const secretValue = 12345n;
const hash = persistentHash(new CompactTypeField(), secretValue);

// Create commitment with randomness
const nonce = new Uint8Array(32); // Random 32 bytes
const commitment = persistentCommit(new CompactTypeField(), secretValue, nonce);
```

### Working with Elliptic Curves

```typescript
import { ecMulGenerator, ecMul, ecAdd } from '@midnight-ntwrk/compact-runtime';

// Generate point from scalar
const scalar = 5n;
const point = ecMulGenerator(scalar);

// Multiply point by scalar
const result = ecMul(point, 3n);

// Add two points
const sum = ecAdd(point, result);
```

### Encoding/Decoding Coins

```typescript
import { encodeCoinInfo, decodeCoinInfo } from '@midnight-ntwrk/compact-runtime';

const coinInfo = {
  nonce: new Uint8Array(32),
  color: new Uint8Array(32),
  value: 1000n,
  mt_index: 42n
};

const encoded = encodeQualifiedCoinInfo(coinInfo);
const decoded = decodeQualifiedCoinInfo(encoded);
```

---

## Best Practices

### 1. Always Set Network ID

```typescript
import { setNetworkId, NetworkId } from '@midnight-ntwrk/compact-runtime';

setNetworkId(NetworkId.TestNet);
```

### 2. Use Persistent Hash for State Data

```typescript
// âœ… GOOD - for deriving state data
const stateHash = persistentHash(type, value);

// âŒ BAD - transient not guaranteed to persist
const transientHash = transientHash(type, value); // Don't use for state!
```

### 3. Handle Errors Appropriately

```typescript
try {
  const hash = persistentHash(opaqueType, value);
} catch (error) {
  // Handle Opaque type error
  console.error("Cannot hash Opaque types:", error);
}
```

### 4. Validate Coin Operations

```typescript
// Always validate before creating inputs/outputs
if (coin.value > 0n) {
  createZswapInput(context, coin);
}
```

---

## Common Errors

### 1. Opaque Type in Hash

```
Error: rt_type encodes a type containing Compact 'Opaque' types
```
**Solution**: Don't hash Opaque types.

### 2. Invalid Opening Length

```
Error: opening is not 32 bytes long
```
**Solution**: Ensure nonce/opening is exactly 32 bytes.

### 3. Invalid Field Element

```
Error: value does not encode a field element
```
**Solution**: Ensure value is within field range (< MAX_FIELD).

---

## Version Information

- **Package**: @midnight-ntwrk/compact-runtime
- **Version**: 0.9.0
- **Last Updated**: October 17, 2025
- **Compatibility**: Minokawa 0.18.0 / Compact Compiler 0.26.0

---

## Related Documentation

For conceptual understanding and usage patterns, see:
- MINOKAWA_LANGUAGE_REFERENCE.md
- COMPACT_STANDARD_LIBRARY.md
- HOW_TO_KEEP_DATA_PRIVATE.md
- MINOKAWA_WITNESS_PROTECTION_DISCLOSURE.md

---

**Status**: âœ… Complete TypeScript API Reference for LLM Training  
**Purpose**: Comprehensive reference for AI-assisted Midnight development  
**Last Updated**: October 28, 2025
